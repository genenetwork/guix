Copied from upstream:
https://hg.mozilla.org/releases/mozilla-esr38/raw-rev/6f4d51302387

# HG changeset patch
# User Andrew McCreight <continuation@gmail.com>
# Date 1456273423 28800
# Node ID 6f4d5130238790fa5810c76ffeb9eccc65efa8c9
# Parent  70f6c59d9d73a5edefd216b48ca74a931da12cf1
Bug 1249685 - Use more nsCOMPtrs for stack variables in DOM code. r=smaug, a=ritu

diff --git a/dom/base/nsRange.cpp b/dom/base/nsRange.cpp
--- a/dom/base/nsRange.cpp
+++ b/dom/base/nsRange.cpp
@@ -1985,17 +1985,17 @@ nsRange::CutContents(DocumentFragment** 
       rv = closestAncestor ? PrependChild(closestAncestor, nodeToResult)
                            : PrependChild(commonCloneAncestor, nodeToResult);
       NS_ENSURE_SUCCESS(rv, rv);
       NS_ENSURE_STATE(!guard.Mutated(parent ? 2 : 1) ||
                       ValidateCurrentNode(this, iter));
     } else if (nodeToResult) {
       nsMutationGuard guard;
       nsCOMPtr<nsINode> node = nodeToResult;
-      nsINode* parent = node->GetParentNode();
+      nsCOMPtr<nsINode> parent = node->GetParentNode();
       if (parent) {
         mozilla::ErrorResult error;
         parent->RemoveChild(*node, error);
         NS_ENSURE_FALSE(error.Failed(), error.ErrorCode());
       }
       NS_ENSURE_STATE(!guard.Mutated(1) ||
                       ValidateCurrentNode(this, iter));
     }
diff --git a/dom/base/nsTreeSanitizer.cpp b/dom/base/nsTreeSanitizer.cpp
--- a/dom/base/nsTreeSanitizer.cpp
+++ b/dom/base/nsTreeSanitizer.cpp
@@ -1423,18 +1423,18 @@ nsTreeSanitizer::SanitizeChildren(nsINod
                              mAllowStyles,
                              false);
         }
         node = node->GetNextNonChildNode(aRoot);
         continue;
       }
       if (MustFlatten(ns, localName)) {
         RemoveAllAttributes(node);
-        nsIContent* next = node->GetNextNode(aRoot);
-        nsIContent* parent = node->GetParent();
+        nsCOMPtr<nsIContent> next = node->GetNextNode(aRoot);
+        nsCOMPtr<nsIContent> parent = node->GetParent();
         nsCOMPtr<nsIContent> child; // Must keep the child alive during move
         ErrorResult rv;
         while ((child = node->GetFirstChild())) {
           parent->InsertBefore(*child, node, rv);
           if (rv.Failed()) {
             break;
           }
         }
diff --git a/dom/html/HTMLSelectElement.cpp b/dom/html/HTMLSelectElement.cpp
--- a/dom/html/HTMLSelectElement.cpp
+++ b/dom/html/HTMLSelectElement.cpp
@@ -624,17 +624,17 @@ HTMLSelectElement::Add(nsGenericHTMLElem
 {
   if (!aBefore) {
     Element::AppendChild(aElement, aError);
     return;
   }
 
   // Just in case we're not the parent, get the parent of the reference
   // element
-  nsINode* parent = aBefore->Element::GetParentNode();
+  nsCOMPtr<nsINode> parent = aBefore->Element::GetParentNode();
   if (!parent || !nsContentUtils::ContentIsDescendantOf(parent, this)) {
     // NOT_FOUND_ERR: Raised if before is not a descendant of the SELECT
     // element.
     aError.Throw(NS_ERROR_DOM_NOT_FOUND_ERR);
     return;
   }
 
   // If the before parameter is not null, we are equivalent to the
diff --git a/dom/html/HTMLTableElement.cpp b/dom/html/HTMLTableElement.cpp
--- a/dom/html/HTMLTableElement.cpp
+++ b/dom/html/HTMLTableElement.cpp
@@ -516,18 +516,18 @@ HTMLTableElement::InsertRow(int32_t aInd
   if (rowCount > 0) {
     if (refIndex == rowCount || aIndex == -1) {
       // we set refIndex to the last row so we can get the last row's
       // parent we then do an AppendChild below if (rowCount<aIndex)
 
       refIndex = rowCount - 1;
     }
 
-    Element* refRow = rows->Item(refIndex);
-    nsINode* parent = refRow->GetParentNode();
+    RefPtr<Element> refRow = rows->Item(refIndex);
+    nsCOMPtr<nsINode> parent = refRow->GetParentNode();
 
     // create the row
     nsRefPtr<mozilla::dom::NodeInfo> nodeInfo;
     nsContentUtils::NameChanged(mNodeInfo, nsGkAtoms::tr,
                                 getter_AddRefs(nodeInfo));
 
     newRow = NS_NewHTMLTableRowElement(nodeInfo.forget());
 

